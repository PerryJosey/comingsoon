const shaderData={uniforms:{iResolution:{type:"v2",value:[window.innerWidth,window.innerHeight]},vTextureSize:{type:"v2",value:[0,0]},uTextureForeground:{type:"sampler2D",value:null},uTextureBackground:{type:"sampler2D",value:null},uTextureDropShine:{type:"sampler2D",value:null}},fragment:`
        precision mediump float;
    
        //Textures
        uniform sampler2D uTextureForeground;
        uniform sampler2D uTextureBackground;
        uniform sampler2D uTextureDropShine;
        
        //Canvas image data
        uniform sampler2D uSampler;
    
        //The resolution and coordinates of the current pixel
        uniform vec2 iResolution;
        uniform vec2 vTextureSize;
        varying vec2 vTextureCoord;
        
        //Function to get the vec2 value of the current coordinate
        vec2 texCoord(){
            return vec2(gl_FragCoord.x, iResolution.y - gl_FragCoord.y) / iResolution;
        }

        //Scales the bg up and proportionally to fill the container
        vec2 scaledTextureCoordinate(){
            float ratioCanvas = iResolution.x / iResolution.y;
            float ratioImage = vTextureSize.x / vTextureSize.y;
            
            vec2 scale = vec2(1, 1);
            vec2 offset = vec2(0, 0);
            float ratioDelta = ratioCanvas - ratioImage;

            if(ratioDelta >= 0.0){
                scale.y = (1.0 + ratioDelta);
                offset.y = ratioDelta / 2.0;
            }else{
                scale.x = (1.0 - ratioDelta);
                offset.x = -(ratioDelta / 2.0);
            }

            return (texCoord() + offset) / scale;
        }
        
        //Alpha-blends two colors
        vec4 blend(vec4 bg, vec4 fg){
            vec3 bgm = bg.rgb * bg.a;
            vec3 fgm = fg.rgb * fg.a;
            float ia = 1.0 - fg.a;
            float a = (fg.a + bg.a * ia);
            
            vec3 rgb;
            
            if(a != 0.0){
                rgb = (fgm + bgm * ia) / a;
            }else{
                rgb = vec3(0.0,0.0,0.0);
            }
            
            return vec4(rgb,a);
        }
        
        vec2 pixel(){
            return vec2(1.0, 1.0) / iResolution;
        }
        
        //Get color from fg
        vec4 fgColor(){
            return texture2D(uSampler, vTextureCoord);
        }
                
        void main(){
            vec4 bg = texture2D(uTextureBackground, scaledTextureCoordinate());
            vec4 cur = fgColor();

            float d = cur.b; // "thickness"
            float x = cur.g;
            float y = cur.r;
            float a = smoothstep(0.65, 0.7, cur.a);
            
            vec4 smoothstepped = vec4(y, x, d, a);

            vec2 refraction = (vec2(x, y) - 0.5) * 2.0;
            vec2 refractionPos = scaledTextureCoordinate() + (pixel() * refraction * (256.0 + (d * 512.0)));
            vec4 tex = texture2D(uTextureForeground, refractionPos);
            
            float maxShine = 390.0;
            float minShine = maxShine * 0.18;
            vec2 shinePos = vec2(0.5, 0.5) + ((1.0 / 512.0) * refraction) * -(minShine + ((maxShine-minShine) * d));
            vec4 shine = texture2D(uTextureDropShine, shinePos);
            tex = blend(tex,shine);
            
            vec4 fg = vec4(tex.rgb, a);
            gl_FragColor = blend(bg, fg);
        }
	`};class Application{constructor(){this.width=window.innerWidth,this.height=window.innerHeight,this.loader=PIXI.loader.add(alpha).add(shine).add(imageWater).load(()=>this.initialize())}initialize(){this.effectCanvas=new EffectCanvas(this.width,this.height,this.loader),window.addEventListener("resize",()=>this.resizeCanvas(),!1),this.loop()}resizeCanvas(){this.width=window.innerWidth,this.height=window.innerHeight,this.effectCanvas.resize(this.width,this.height)}loop(){window.requestAnimationFrame(()=>this.loop()),this.effectCanvas.update(this.width,this.height),this.effectCanvas.render()}}class EffectCanvas{constructor(e,t,n){this.renderer=new PIXI.autoDetectRenderer(e,t,{antialias:!1,transparent:!1,view:document.getElementById("water-droplet")}),this.renderer.autoResize=!0,this.stage=new PIXI.Container,this.background=new PIXI.Graphics,this.background.fillAlphanumber=0,this.background.beginFill("0xffffff"),this.background.drawRect(0,0,e,t),this.background.endFill(),this.background.alpha=0,this.stage.addChild(this.background),this.dropletManager=new DropletManager(this.stage,n),shaderData.uniforms.uTextureDropShine.value=n.resources[shine].texture,shaderData.uniforms.uTextureBackground.value=n.resources[imageWater].texture,shaderData.uniforms.uTextureForeground.value=n.resources[imageWater].texture,shaderData.uniforms.vTextureSize.value=[n.resources[imageWater].texture.width,n.resources[imageWater].texture.height],this.dropletShader=new PIXI.Filter("",shaderData.fragment,shaderData.uniforms),this.stage.filters=[this.dropletShader]}resize(e,t){this.renderer.resize(e,t),this.background.clear(),this.background.beginFill("0xffffff"),this.background.drawRect(0,0,e,t),this.background.endFill()}update(e,t){this.updateShader(e,t),this.dropletManager.update(e,t)}updateShader(e,t){this.dropletShader.uniforms.iResolution=[e,t]}render(){this.renderer.render(this.stage)}}class DropletManager{constructor(e,t){let n=9e3,s=200;e.width<700&&(n=3e3,s=150),this.options={spawnRate:{small:.6,large:.05},spawnsPerFrame:{small:200,large:5},spawnMass:{small:{min:1,max:2},large:{min:7,max:10}},poolDroplets:{small:{min:n-500,max:n},large:{min:s-100,max:s}},maximumMassGravity:maximumMassGravity_water,maximumMass:maximumMass_water,dropletGrowSpeed:dropletGrowSpeed_water,dropletShrinkSpeed:dropletShrinkSpeed_water,dropletContainerSize:100},this.positionMatrix=[[-1,-1],[1,-1],[-1,1],[1,1]],this.smallDroplets=[],this.largeDroplets=[],this.dropletSmallTexture=t.resources[alpha].texture,this.dropletLargeTexture=t.resources[alpha].texture,this.smallDropletContainer=new DropletPool(Droplet,this.dropletSmallTexture,this.options.poolDroplets.small.min,this.options.poolDroplets.small.max),this.largeDropletContainer=new DropletPool(LargeDroplet,this.dropletLargeTexture,this.options.poolDroplets.large.min,this.options.poolDroplets.large.max),e.addChild(this.largeDropletContainer),e.addChild(this.smallDropletContainer)}update(e,t){DropletManager.removeLargeOffscreenDroplets(e,t,this.largeDroplets,this.largeDropletContainer);for(let n=0;n<this.options.spawnsPerFrame.small;n++)this.spawnNewSmallDroplet(e,t);for(let n=0;n<this.options.spawnsPerFrame.large;n++)this.spawnNewLargeDroplet(e,t);this.checkLargeDropletLogic()}checkLargeDropletLogic(){for(let e=this.largeDroplets.length-1;e>=0;e--)this.updateLargeDropletSize(this.largeDroplets[e]),this.checkDropletMovement(this.largeDroplets[e]),this.checkLargeToSmallDropletCollision(this.largeDroplets[e]),this.checkLargeToLargeDropletCollision(this.largeDroplets[e]),this.removeLargeDroplets(e)}removeLargeDroplets(e){0===this.largeDroplets[e].mass&&!0===this.largeDroplets[e].toBeRemoved&&(this.largeDropletContainer.destroy(this.largeDroplets[e]),this.largeDroplets.splice(e,1))}updateLargeDropletSize(e){!0===e.toBeRemoved?this.shrinkDropletSize(e):this.growDropletSize(e),e.width=6*e.mass,e.height=7*e.mass}shrinkDropletSize(e){e.mass-this.options.dropletShrinkSpeed<=0?e.mass=0:e.mass-=this.options.dropletShrinkSpeed}growDropletSize(e){e.mass!==e.targetMass&&(e.mass+this.options.dropletGrowSpeed>=e.targetMass?e.mass=e.targetMass:e.mass+=this.options.dropletGrowSpeed)}checkDropletMovement(e){!0!==e.toBeRemoved&&(e.mass<this.options.maximumMassGravity&&0===e.dropletVelocity.y&&0===e.dropletVelocity.x?Math.random()<.01&&(e.dropletVelocity.y=Utils.getRandomInt(.5,3)):e.mass<this.options.maximumMassGravity&&0!==e.dropletVelocity.y?(Math.random()<.1&&(e.x+=Utils.getRandomInt(-10,10)/10),Math.random()<.1&&(e.dropletVelocity.y=0)):e.mass>=this.options.maximumMassGravity&&e.dropletVelocity.y<10&&(e.dropletVelocity.y=Utils.getRandomInt(10,20),e.dropletVelocity.x=Utils.getRandomInt(-10,10)/10),e.y+=e.dropletVelocity.y,e.x+=e.dropletVelocity.x)}getDropletPresenceArray(e){const t=[],n=this.positionMatrix.length;for(let s=0;s<n;s++){const o={x:Math.floor((e.x+e.width/7*this.positionMatrix[s][0])/this.options.dropletContainerSize),y:Math.floor((e.y+e.height/7*this.positionMatrix[s][1])/this.options.dropletContainerSize)};0!==s?t[0].x===o.x&&t[0].y===o.y||t.push(o):t.push(o)}return t}checkLargeToLargeDropletCollision(e){if(!0===e.toBeRemoved)return;for(let t=this.largeDroplets.length-1;t>=0;t--){if(e.x===this.largeDroplets[t].x&&e.y===this.largeDroplets[t].y)continue;const n=e.x-this.largeDroplets[t].x,s=e.y-this.largeDroplets[t].y;Math.sqrt(n*n+s*s)<=e.width/7+this.largeDroplets[t].width/7&&(e.mass+this.largeDroplets[t].mass<=this.options.maximumMass?e.targetMass=e.mass+this.largeDroplets[t].mass:e.targetMass=this.options.maximumMass,this.largeDroplets[t].toBeRemoved=!0)}}checkLargeToSmallDropletCollision(e){if(!0===e.toBeRemoved)return;const t=this.getDropletPresenceArray(e);for(let n=0;n<t.length;n++){if(void 0===this.smallDroplets[t[n].x]||void 0===this.smallDroplets[t[n].x][t[n].y])continue;for(let s=this.smallDroplets[t[n].x][t[n].y].length-1;s>=0;s--){const o=e.x-this.smallDroplets[t[n].x][t[n].y][s].x,i=e.y-this.smallDroplets[t[n].x][t[n].y][s].y;Math.sqrt(o*o+i*i)<=e.width/7+this.smallDroplets[t[n].x][t[n].y][s].width/7&&(e.mass+this.smallDroplets[t[n].x][t[n].y][s].mass/3<=this.options.maximumMass&&(e.targetMass=e.mass+this.smallDroplets[t[n].x][t[n].y][s].mass/3),this.smallDropletContainer.destroy(this.smallDroplets[t[n].x][t[n].y][s]),this.smallDroplets[t[n].x][t[n].y].splice(s,1))}}}spawnNewSmallDroplet(e,t){if(Math.random()>this.options.spawnRate.small)return;const n=this.smallDropletContainer.get();if(null===n)return;const o={x:Utils.getRandomInt(0,e),y:Utils.getRandomInt(0,t)},a=Utils.getRandomInt(this.options.spawnMass.small.min,this.options.spawnMass.small.max),s=Math.floor(o.x/this.options.dropletContainerSize),i=Math.floor(o.y/this.options.dropletContainerSize);n.x=o.x,n.y=o.y,n.mass=a,n.width=8*n.mass,n.height=8*n.mass,void 0===this.smallDroplets[s]&&(this.smallDroplets[s]=[]),void 0===this.smallDroplets[s][i]&&(this.smallDroplets[s][i]=[]),this.smallDroplets[s][i].push(n)}spawnNewLargeDroplet(e,t){if(Math.random()>this.options.spawnRate.large)return;const n=this.largeDropletContainer.get();if(null===n)return;const s=Utils.getRandomInt(this.options.spawnMass.large.min,this.options.spawnMass.large.max);n.x=Utils.getRandomInt(0,e),n.y=Utils.getRandomInt(-100,t/1.5),n.mass=s/2,n.targetMass=s,n.width=6*n.mass,n.height=7*n.mass,n.dropletVelocity.x=0,n.toBeRemoved=!1,this.largeDroplets.push(n)}static removeLargeOffscreenDroplets(e,t,n,s){for(let o=n.length-1;o>=0;o--)(n[o].x>e+10||n[o].x<-10||n[o].y>t+10||n[o].y<-100)&&(s.destroy(n[o]),n.splice(o,1))}}class DropletPool extends PIXI.particles.ParticleContainer{constructor(e,t,n,s){super(s,{scale:!0,position:!0,rotation:!1,uvs:!1,alpha:!1}),this.ObjectToCreate=e,this.objectTexture=t,this.pool=[],this.inUse=0,this.startingSize=n,this.maximumSize=s,this.initialize()}initialize(){for(let t=0;t<this.startingSize;t+=1){const e=new this.ObjectToCreate(this.objectTexture);e.x=-100,e.y=-100,e.anchor.set(.5),this.addChild(e),this.pool.push(e)}}get(){if(this.inUse>=this.maximumSize)return null;if(this.inUse++,this.pool.length>0)return this.pool.pop();const e=new this.ObjectToCreate(this.objectTexture);return e.x=-100,e.y=-100,e.anchor.set(.5,.5),this.addChild(e),e}destroy(e){this.inUse-1<0?console.error("Something went wrong, you cant remove more elements than there are in the total pool"):(e.x=-100,e.y=-100,this.inUse-=1,this.pool.push(e))}}class Droplet extends PIXI.Sprite{constructor(e){super(e),this.mass=0}}class LargeDroplet extends Droplet{constructor(e){super(e),this.dropletVelocity=new PIXI.Point(0,0),this.toBeRemoved=!1,this.targetMass=0}}class Utils{static getRandomInt(e,t){return Math.floor(Math.random()*(t-e+1))+e}}window.onload=()=>{new Application}